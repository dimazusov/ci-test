name: SSH Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.OPTIMIZATION_VPS_PRIVATE_KEY }}
          ssh-known-hosts: ${{ secrets.optimization-prod.OPTIMIZATION_VPS_SSH_KNOWN_HOSTS }}

      - name: Run command on remote server
        run: ssh ${{ vars.OPTIMIZATION_VPS_USER }}@${{ vars.OPTIMIZATION_VPS_HOST }} "touch test.txt"

#name: Remote Commands Execution
#
#on:
#  push:
#    branches:
#      - main
#  pull_request:
#    branches: [ "main" ]
#
#jobs:
#  build_and_push_to_dockerhub:
#      # Если тесты были пройдены успешно
#      needs: [run_tests]
#      runs-on: [ubuntu-latest]
#      env:
#        LOGIN: ${{ secrets.DOCKER_LOGIN }}
#        NAME: ${{ secrets.DOCKER_NAME }}
#      steps:
#        - name: Login to docker.io
#          # Сначала мы логинимся в docker.io
#          run:  echo ${{ secrets.DOCKER_PWD }} | docker login -u ${{ secrets.DOCKER_LOGIN }} --password-stdin
#          # Чекаутим код
#        - uses: actions/checkout@master
#        - name: Build image
#          # Собираем image и называем его так как указано в hub.docker т.е. login/repository:version
#          run: docker build -t $LOGIN/$NAME:${GITHUB_REF:11} -f Dockerfile .
#        - name: Push image to docker.io
#          # Пушим образ в registry
#          run: docker push $LOGIN/$NAME:${GITHUB_REF:11}

#  execute_commands:
#    runs-on: ubuntu-latest
#
#    steps:
#      - name: Connect to Remote Machine
#        uses: applejxd/ssh-action@v2
#        with:
#          host: ${{ secrets.REMOTE_HOST }}
#          username: ${{ secrets.REMOTE_USER }}
#          key: ${{ secrets.SSH_PRIVATE_KEY }}
#          port: ${{ secrets.REMOTE_PORT }}
#
#      - name: Run Command 1
#        run: echo 1
#
#      - name: Run Command 2
#        run: echo 2

#name: Publish on Docker Hub and Deploy
#
#on:
#  # Запуск при пуше в мастер или pull request'e
#  push:
#    branches: [ "master" ]
#  pull_request:
#    branches: [ "master" ]
#
#jobs:
#  run_tests:
#    # версия контейнера для запуска
#    runs-on: [ubuntu-latest]
#    steps:
#      # чекаут ветки
#      - uses: actions/checkout@master
#
#      - name: Set up Go
#        uses: actions/setup-go@v4
#        with:
#          go-version: '1.20'
#
#      - name: Build
#        run: go build ./...
#
#      - name: Test
#        run: go test -v ./...
#
#
#  build_and_push_to_dockerhub:
#    # Если тесты были пройдены успешно
#    needs: [run_tests]
#    runs-on: [ubuntu-latest]
#    env:
#      LOGIN: ${{ secrets.DOCKER_LOGIN }}
#      NAME: ${{ secrets.DOCKER_NAME }}
#    steps:
#      - name: Login to docker.io
#        # Сначала мы логинимся в docker.io
#        run:  echo ${{ secrets.DOCKER_PWD }} | docker login -u ${{ secrets.DOCKER_LOGIN }} --password-stdin
#        # Чекаутим код
#      - uses: actions/checkout@master
#      - name: Build image
#        # Собираем image и называем его так как указано в hub.docker т.е. login/repository:version
#        run: docker build -t $LOGIN/$NAME:${GITHUB_REF:11} -f Dockerfile .
#      - name: Push image to docker.io
#        # Пушим образ в registry
#        run: docker push $LOGIN/$NAME:${GITHUB_REF:11}
#
#  deploy:
#    # Если мы успешно собрали контейнер и отправили в registry, то делаем хук деплоймент серверу
#    # Попробуем готовый экшен curl из маркетплэйса
#    needs: [build_and_pub]
#    runs-on: [ubuntu-latest]
#    steps:
#      - name: Set tag to env
#        run: echo ::set-env name=RELEASE_VERSION::$(echo ${GITHUB_REF:11})
#      - name: Send webhook for deploy
#        run: "curl --silent --show-error --fail -X POST ${{ secrets.DEPLOYMENT_SERVER }} -H 'Authorization: ${{ secrets.DEPLOYMENT_TOKEN }}' -H 'Content-Type: application/json' -d '{\"owner\": \"${{ secrets.DOCKER_LOGIN }}\", \"repository\": \"${{ secrets.DOCKER_NAME }}\", \"tag\": \"${{ env.RELEASE_VERSION }}\", \"ports\": {\"8080\": 8080}}'"